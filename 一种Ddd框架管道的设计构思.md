# 本文最早发表于

https://github.com/netcorepal/netcorepal-cloud-framework/issues/131

# 标题

一种Ddd框架，管道，的设计构思

# 设计的大概内容

## 领域事件储存在`命令`实例中

每一个`命令`实例，都可以携带，自己的，若干个，领域事件
由此命令的，处理器，负责，把所需领域事件，添加到，命令实例，里面

## 业务代码，使用，定制的中介者
使用，定制的中介者，来写业务代码，不使用，MediatR
确保，业务先进入，定制的中介者，再由，定制的中介者，提交给，MediatR

## 定制的中介者，执行`命令`的步骤

### 做模型验证
### DBMS事务的开启
如果当前DBMS事务，为空，则开启，新的DBMS事务，非空，则不开启
（为第一个命令，开启DBMS事务）
此DBMS事务，是当前方法代码中的，一个可空引用类型，的变量，transaction
### 进入分布式锁
（如果需要进入）
判断，是否，需要进入，分布式锁的方式
可以是通过，让`命令`实现某接口，或者是，标注某个，自定义Attribute
### 本体的执行
可用，原生的，MediatR实现
### SaveChangesAsync
### 释放分布式锁
释放，当前方法代码中，开启的，分布式锁
（如果需要释放）
### 逐个处理`命令`中携带的，领域事件
最后，清空`命令`中携带的，领域事件
### 释放DBMS事务
（如果需要的话）
根据transaction的可空性，即可判断
### 返回响应（如需要）

## 定制的中介者，执行`查询`的步骤

### 做模型验证
### 尝试从分布式缓存中获取响应
（如果需要）
判断，是否，需要从，分布式缓存中，获取响应
可以是，通过，让`查询`实现某接口，或者是，标注某个，自定义Attribute
### 如上一步，没有成功，则执行本体
可以用原始的，Mediatr实现
### 返回响应

## 定制的中介者，执行`DomainEvent`的步骤

`DomainEventHandler`的操作内容，通常，只能是

中介者执行`查询`+中介者执行`命令`
或
中介者执行`命令`

因此，`DomainEventHandler`的执行，大概，不需要有管道相关的设计

# 设计的优势

可能，可以，很好的整合(逻辑无bug)，DBMS事务、验证器、分布式锁、分布式缓存
